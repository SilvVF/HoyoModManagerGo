// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: playlist_queries.sql

package db

import (
	"context"
	"database/sql"
)

const deletePlaylistById = `-- name: DeletePlaylistById :exec
DELETE FROM playlist WHERE id = ?1
`

func (q *Queries) DeletePlaylistById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePlaylistById, id)
	return err
}

const enableModsForPlaylist = `-- name: EnableModsForPlaylist :exec
UPDATE mod SET
    selected = TRUE
WHERE mod.id in (
    SELECT playlist_mod_cross_ref.mod_id FROM playlist_mod_cross_ref
    WHERE playlist_id = ?1
) AND mod.game = ?2
`

type EnableModsForPlaylistParams struct {
	PlaylistId int64
	Game       int64
}

func (q *Queries) EnableModsForPlaylist(ctx context.Context, arg EnableModsForPlaylistParams) error {
	_, err := q.db.ExecContext(ctx, enableModsForPlaylist, arg.PlaylistId, arg.Game)
	return err
}

const insertPlayListModCrossRef = `-- name: InsertPlayListModCrossRef :exec
INSERT INTO playlist_mod_cross_ref (
    playlist_id,
    mod_id
) VALUES (
    ?1,
    ?2
)
`

type InsertPlayListModCrossRefParams struct {
	PlaylistId int64
	ModId      int64
}

func (q *Queries) InsertPlayListModCrossRef(ctx context.Context, arg InsertPlayListModCrossRefParams) error {
	_, err := q.db.ExecContext(ctx, insertPlayListModCrossRef, arg.PlaylistId, arg.ModId)
	return err
}

const insertPlaylist = `-- name: InsertPlaylist :one
INSERT INTO playlist(
    playlist_name,
    game
) VALUES (
    ?1,
    ?2
)
RETURNING id
`

type InsertPlaylistParams struct {
	PlaylistName string
	Game         int64
}

func (q *Queries) InsertPlaylist(ctx context.Context, arg InsertPlaylistParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertPlaylist, arg.PlaylistName, arg.Game)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const selectPlaylistWithModsAndTags = `-- name: SelectPlaylistWithModsAndTags :many


SELECT 
    p.id, p.playlist_name, p.game,
    m.id, m.fname, m.game, m.char_name, m.char_id, m.selected, m.preview_images, m.gb_id, m.mod_link, m.gb_file_name, m.gb_download_link,
    t.mod_id, t.tag_name
FROM 
    playlist p
JOIN 
    playlist_mod_cross_ref pmcr ON p.id = pmcr.playlist_id
JOIN 
    mod m ON pmcr.mod_id = m.id
LEFT JOIN 
    tag t ON m.id = t.mod_id
WHERE p.game = ?1
ORDER BY m.char_name, m.fname
`

type SelectPlaylistWithModsAndTagsRow struct {
	ID             int64
	PlaylistName   string
	Game           int64
	ID_2           int64
	Fname          string
	Game_2         int64
	CharName       string
	CharID         int64
	Selected       bool
	PreviewImages  string
	GbID           sql.NullInt64
	ModLink        sql.NullString
	GbFileName     sql.NullString
	GbDownloadLink sql.NullString
	ModID          sql.NullInt64
	TagName        sql.NullString
}

// playlist(
//
//	id INTEGER PRIMARY KEY NOT NULL,
//	playlist_name TEXT NOT NULL DEFAULT '',
//	game INTEGER NOT NULL
//
// );
// CREATE TABLE IF NOT EXISTS playlist_mod_cross_ref(
//
//	playlist_id INTEGER NOT NULL,
//	mod_id INTEGER NOT NULL,
//	PRIMARY KEY (playlist_id, mod_id),
//	FOREIGN KEY (mod_id) REFERENCES mod(id) ON DELETE CASCADE,
//	FOREIGN KEY (playlist_id) REFERENCES playlist(id) ON DELETE CASCADE
//
// );
func (q *Queries) SelectPlaylistWithModsAndTags(ctx context.Context, game int64) ([]SelectPlaylistWithModsAndTagsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectPlaylistWithModsAndTags, game)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectPlaylistWithModsAndTagsRow
	for rows.Next() {
		var i SelectPlaylistWithModsAndTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.PlaylistName,
			&i.Game,
			&i.ID_2,
			&i.Fname,
			&i.Game_2,
			&i.CharName,
			&i.CharID,
			&i.Selected,
			&i.PreviewImages,
			&i.GbID,
			&i.ModLink,
			&i.GbFileName,
			&i.GbDownloadLink,
			&i.ModID,
			&i.TagName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectPlaylists = `-- name: SelectPlaylists :many
SELECT id, playlist_name, game FROM playlist
`

func (q *Queries) SelectPlaylists(ctx context.Context) ([]Playlist, error) {
	rows, err := q.db.QueryContext(ctx, selectPlaylists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playlist
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(&i.ID, &i.PlaylistName, &i.Game); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlaylistName = `-- name: UpdatePlaylistName :exec
UPDATE playlist SET
    playlist_name = ?1
WHERE id = ?2
`

type UpdatePlaylistNameParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdatePlaylistName(ctx context.Context, arg UpdatePlaylistNameParams) error {
	_, err := q.db.ExecContext(ctx, updatePlaylistName, arg.Name, arg.ID)
	return err
}
