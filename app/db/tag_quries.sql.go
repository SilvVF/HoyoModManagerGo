// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tag_quries.sql

package db

import (
	"context"
)

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tag WHERE tag_name = ?1 AND mod_id = ?2
`

type DeleteTagParams struct {
	Name  string
	ModId int64
}

func (q *Queries) DeleteTag(ctx context.Context, arg DeleteTagParams) error {
	_, err := q.db.ExecContext(ctx, deleteTag, arg.Name, arg.ModId)
	return err
}

const insertTag = `-- name: InsertTag :exec
INSERT OR IGNORE INTO tag(tag_name, mod_id) VALUES(?1, ?2)
`

type InsertTagParams struct {
	TagName string
	ModId   int64
}

func (q *Queries) InsertTag(ctx context.Context, arg InsertTagParams) error {
	_, err := q.db.ExecContext(ctx, insertTag, arg.TagName, arg.ModId)
	return err
}

const selectTagsByModId = `-- name: SelectTagsByModId :many
SELECT mod_id, tag_name FROM tag WHERE mod_id = ?1
`

func (q *Queries) SelectTagsByModId(ctx context.Context, modid int64) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, selectTagsByModId, modid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ModID, &i.TagName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTagName = `-- name: UpdateTagName :exec

UPDATE tag SET 
    tag_name = ?1
WHERE mod_id = ?2 AND tag_name = ?3
`

type UpdateTagNameParams struct {
	UpdatedName string
	ID          int64
	OldName     string
}

// tag(
//
//	mod_id INTEGER NOT NULL,
//	tag_name TEXT NOT NULL DEFAULT '',
//	PRIMARY KEY(mod_id, tag_name),
//	FOREIGN KEY(mod_id) REFERENCES mod(id) ON DELETE CASCADE
//
// );
func (q *Queries) UpdateTagName(ctx context.Context, arg UpdateTagNameParams) error {
	_, err := q.db.ExecContext(ctx, updateTagName, arg.UpdatedName, arg.ID, arg.OldName)
	return err
}
